import { Platform } from '../utils/platform';
import { FileSystemService } from './fileSystemService';

/**
 * Service for securely handling API tokens
 */
export class TokenService {
  /**
   * Validates a Hugging Face API token
   * @param token API token to validate
   * @returns Promise resolving to validation result
   */
  static async validateHuggingFaceToken(token: string): Promise<{
    isValid: boolean;
    username?: string;
    error?: string;
  }> {
    try {
      // In a real app, this would make an API request to HF
      // For this example, we'll simulate it
      if (!token || token.length < 8) {
        return { isValid: false, error: "Invalid token format" };
      }

      // Simulate API call to HF
      const isValidToken = token.startsWith('hf_') && token.length >= 8;
      
      if (isValidToken) {
        return { 
          isValid: true, 
          username: "demo_user" // This would come from the API
        };
      } else {
        return { isValid: false, error: "Invalid token" };
      }
    } catch (error: any) {
      console.error("Token validation error:", error);
      return { 
        isValid: false, 
        error: error.message || "Failed to validate token" 
      };
    }
  }

  /**
   * Securely stores a token in the OS credential store
   * @param tokenName Name/key for the token
   * @param tokenValue Token value to store
   * @returns Promise resolving when token is stored
   */
  static async storeToken(tokenName: string, tokenValue: string): Promise<boolean> {
    try {
      // In a desktop app, this would use the OS credential store
      // For this web demo, we'll simulate it
      
      if (Platform.isDesktopEnvironment()) {
        // Simulate a call to the OS credential store via Electron
        await (window as any).electron.storeCredential(tokenName, tokenValue);
        return true;
      } else {
        // For web, we'll use sessionStorage (not for production use!)
        // In a real app, consider more secure alternatives
        sessionStorage.setItem(`token_${tokenName}`, tokenValue);
        return true;
      }
    } catch (error) {
      console.error("Failed to store token:", error);
      return false;
    }
  }

  /**
   * Retrieves a token from secure storage
   * @param tokenName Name/key of the token to retrieve
   * @returns Promise resolving to token value or null
   */
  static async getToken(tokenName: string): Promise<string | null> {
    try {
      if (Platform.isDesktopEnvironment()) {
        // Simulate a call to the OS credential store via Electron
        return await (window as any).electron.getCredential(tokenName);
      } else {
        // For web demo only
        return sessionStorage.getItem(`token_${tokenName}`);
      }
    } catch (error) {
      console.error("Failed to retrieve token:", error);
      return null;
    }
  }

  /**
   * Removes a token from secure storage
   * @param tokenName Name/key of the token to remove
   * @returns Promise resolving when token is removed
   */
  static async removeToken(tokenName: string): Promise<boolean> {
    try {
      if (Platform.isDesktopEnvironment()) {
        // Simulate a call to the OS credential store via Electron
        await (window as any).electron.removeCredential(tokenName);
        return true;
      } else {
        // For web demo only
        sessionStorage.removeItem(`token_${tokenName}`);
        return true;
      }
    } catch (error) {
      console.error("Failed to remove token:", error);
      return false;
    }
  }

  /**
   * Creates a wrapper script for secure token usage
   * @param scriptType Type identifier for the script
   * @param tokenName Name/key of the token in secure storage
   * @param additionalParams Additional parameters for the script
   * @returns Promise resolving to path of created script
   */
  static async createWrapperScript(
    scriptType: string, 
    tokenName: string, 
    additionalParams: Record<string, any> = {}
  ): Promise<string> {
    if (!Platform.isDesktopEnvironment()) {
      throw new Error("Wrapper scripts can only be created in desktop environment");
    }

    try {
      // This would generate an appropriate script based on platform
      const isWindows = Platform.isWindows();
      let scriptContent = '';
      
      if (isWindows) {
        scriptContent = `
# Token wrapper script for ${scriptType}
# Generated by MCP Configuration Tool

$env:API_TOKEN = "$(Get-StoredCredential -Target "${tokenName}")"
npx @llmindset/mcp-${scriptType} ${this.formatAdditionalParams(additionalParams)}
`;
      } else {
        scriptContent = `#!/bin/bash
# Token wrapper script for ${scriptType}
# Generated by MCP Configuration Tool

export API_TOKEN="$(security find-generic-password -a "$USER" -s "${tokenName}" -w)"
npx @llmindset/mcp-${scriptType} ${this.formatAdditionalParams(additionalParams)}
`;
      }

      // Create the script directory
      const scriptDir = isWindows 
        ? `${Platform.getAppDataPath()}\\MCP-Config` 
        : `${Platform.getHomePath()}/.mcp-config`;
        
      await FileSystemService.createDirectoryIfNotExists(scriptDir);
      
      // Save the script
      const scriptPath = isWindows
        ? `${scriptDir}\\${scriptType}_wrapper.ps1`
        : `${scriptDir}/${scriptType}_wrapper.sh`;
        
      await FileSystemService.writeFile(scriptPath, scriptContent);
      
      // On Unix systems, make the script executable
      if (!isWindows) {
        await (window as any).electron.makeFileExecutable(scriptPath);
      }
      
      return scriptPath;
    } catch (error) {
      console.error("Failed to create wrapper script:", error);
      throw error;
    }
  }

  /**
   * Formats additional parameters for wrapper scripts
   * @param params Parameter object
   * @returns Formatted parameter string
   */
  private static formatAdditionalParams(params: Record<string, any>): string {
    return Object.entries(params)
      .map(([key, value]) => `--${key} "${value}"`)
      .join(' ');
  }
}
